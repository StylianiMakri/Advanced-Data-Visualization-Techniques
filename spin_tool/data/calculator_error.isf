Fname	calculator_mockerror.pml
===start Model Spec===
1	// reverse polish
2	
3	#define N 12
4	
5	mtype = { operator, value }
6	
7	chan f = [N] of { mtype, int }
8	
9	proctype calc(chan you)
10	{	int s, lft, rgt
11		chan me = [0] of { int }
12	 	calc_started: 
13	
14		if
15		:: f?operator(s)
16			run calc(me); me?lft
17			run calc(me); me?rgt
18			if
19			:: s == '+' -> you!(lft+rgt)
20			:: s == '-' -> you!(lft-rgt)
21			:: s == '*' -> you!(lft*rgt)
22			:: s == '/' -> assert(rgt != 0)
23				       you!(lft/rgt)
24			:: else -> assert(false)
25			fi
26		:: f?value(s) -> you!s; result_produced: skip
27		fi
28	}
29	
30	init {
31		chan me = [0] of { int }
32		int result
33	
34		f!operator('+')
35		f!operator('/')
36		f!value(84)
37		f!value(0)
38		f!operator('-')
39		f!value(36)
40		f!operator('*')
41		f!value(3)
42		f!value(4)
43	
44		run calc(me); me?result
45		printf("result: %d\n", result)
46	}   


===end Model Spec===
===start Model Log===
Spin Version 6.5.2 -- 21 June 2024
iSpin Version 1.1.5 -- 28 May 2021
TclTk Version 8.6/8.6
1 /cygdrive/c/Users/stell/Desktop/Spin-master/Examples/calculator_mockerror.pml:1
2 <saved calculator_mockerror.pml>
3 calculator_mockerror.pml:1
4 syntax check
spin: nothing to report
5 redundancies
spin: no redundancies found (for given property)
Symbol Table Information for calculator_mockerror.pml:
mtype 	operator	2	<:global:>	<constant>	{scope _}
mtype 	value	1	<:global:>	<constant>	{scope _}
chan  	f	12	<:global:>	<variable>	2	mtype 	int   	{scope _}
proctype	calc	0	<:global:>	<variable>	{scope _}
chan  	you	0	<calc>	<parameter 1>	0		{scope _}
int   	s	0	<calc>	<variable>	{scope _3_}
int   	lft	0	<calc>	<variable>	{scope _3_}
int   	rgt	0	<calc>	<variable>	{scope _3_}
chan  	me	0	<calc>	<variable>	1	int   	{scope _3_}
chan  	me	0	<:init:>	<variable>	1	int   	{scope _4_}
int   	result	0	<:init:>	<variable>	{scope _4_}
label	calc_started	22	<calc>	{scope _3_}
label	result_produced	21	<calc>	{scope _3_}
6 simulate/replay
7 verification
8 simulate/replay
9 verification
save verification output in pan_calc_error.out
10 simulate/replay
11 verification


===end Model Log===
Seed	123
Trail	calculator_mockerror.pml.trail
SkipStep	0
MaxStep	10000
VarVals	1
FullQ	0
MSC_Full	0
MaxText	20
Delay	25
Pids	
Qids	
Vars	
Track	
Scale	
===start Data===
[variable values, step  25]

 :init:(0):result  =  0
 calc(1):lft  =  0
 calc(1):rgt  =  0
 calc(1):s  =  43
 calc(2):lft  =  84
 calc(2):rgt  =  0
 calc(2):s  =  47
 calc(3):s  =  84
 calc(4):s  =  0


===end Data===
===start Sim===
  0:	proc  - (:root:) creates proc  0 (:init:)
  1:	proc  0 (:init::1) calculator_mockerror.pml:34 (state 1)	[f!operator,43]
  2:	proc  0 (:init::1) calculator_mockerror.pml:35 (state 2)	[f!operator,47]
  3:	proc  0 (:init::1) calculator_mockerror.pml:36 (state 3)	[f!value,84]
  4:	proc  0 (:init::1) calculator_mockerror.pml:37 (state 4)	[f!value,0]
  5:	proc  0 (:init::1) calculator_mockerror.pml:38 (state 5)	[f!operator,45]
  6:	proc  0 (:init::1) calculator_mockerror.pml:39 (state 6)	[f!value,36]
  7:	proc  0 (:init::1) calculator_mockerror.pml:40 (state 7)	[f!operator,42]
  8:	proc  0 (:init::1) calculator_mockerror.pml:41 (state 8)	[f!value,3]
  9:	proc  0 (:init::1) calculator_mockerror.pml:42 (state 9)	[f!value,4]
Starting calc with pid 1
 10:	proc  0 (:init::1) creates proc  1 (calc)
 10:	proc  0 (:init::1) calculator_mockerror.pml:44 (state 10)	[(run calc(me))]
 11:	proc  1 (calc:1) calculator_mockerror.pml:15 (state 1)	[f?operator,s]
Starting calc with pid 2
 12:	proc  1 (calc:1) creates proc  2 (calc)
 12:	proc  1 (calc:1) calculator_mockerror.pml:16 (state 2)	[(run calc(me))]
 13:	proc  2 (calc:1) calculator_mockerror.pml:15 (state 1)	[f?operator,s]
Starting calc with pid 3
 14:	proc  2 (calc:1) creates proc  3 (calc)
 14:	proc  2 (calc:1) calculator_mockerror.pml:16 (state 2)	[(run calc(me))]
 15:	proc  3 (calc:1) calculator_mockerror.pml:26 (state 19)	[f?value,s]
 16:	proc  3 (calc:1) calculator_mockerror.pml:26 (state 20)	[you!s]
 16:	proc  2 (calc:1) calculator_mockerror.pml:16 (state 3)	[me?lft]
Starting calc with pid 4
 17:	proc  2 (calc:1) creates proc  4 (calc)
 17:	proc  2 (calc:1) calculator_mockerror.pml:17 (state 4)	[(run calc(me))]
 18:	proc  3 (calc:1) calculator_mockerror.pml:26 (state 21)	[(1)]
 19:	proc  4 (calc:1) calculator_mockerror.pml:26 (state 19)	[f?value,s]
 20:	proc  4 (calc:1) calculator_mockerror.pml:26 (state 20)	[you!s]
 20:	proc  2 (calc:1) calculator_mockerror.pml:17 (state 5)	[me?rgt]
 21:	proc  4 (calc:1) calculator_mockerror.pml:26 (state 21)	[(1)]
 23:	proc  2 (calc:1) calculator_mockerror.pml:22 (state 12)	[((s==47))]
 24:	proc  4 (calc:1) terminates
 24:	proc  3 (calc:1) terminates
spin: calculator_mockerror.pml:22, Error: assertion violated
spin: text of failed assertion: assert((rgt!=0))
#processes: 3
 25:	proc  2 (calc:1) calculator_mockerror.pml:22 (state 13)
 25:	proc  1 (calc:1) calculator_mockerror.pml:16 (state 3)
 25:	proc  0 (:init::1) calculator_mockerror.pml:44 (state 11)
5 processes created


===end Sim===
===start Queues===
[queues, step  24]

q 2  :: (f): [operator,45][value,36][operator,42][value,3][value,4]


===end Queues===
LTL_Panel	0
a_mode	1
bc_mode	0
bc_bound	0
bf_mode	0
c_mode	0
cc_mode	0
e_mode	1
estop		0
f_mode	0
it_mode	0
ma_mode	0
p_mode	0
peg		0
po_mode	1
q_mode	0
s_mode	0
sv_mode	0
u_mode	1
vranges	0
x_mode	0
===start VerOut===
verification result:
spin -a  calculator_mockerror.pml
gcc -DMEMLIM=1024 -O2 -DXUSAFE -DSAFETY -DNOCLAIM -w -o pan pan.c
./pan -m10000 
Pid: 2059
pan:1: assertion violated (rgt!=0) (at depth 25)
pan: wrote calculator_mockerror.pml.trail

(Spin Version 6.5.2 -- 21 June 2024)
Warning: Search not completed
	+ Partial Order Reduction

Full statespace search for:
	never claim         	- (not selected)
	assertion violations	+
	cycle checks       	- (disabled by -DSAFETY)
	invalid end states	+

State-vector 224 byte, depth reached 25, errors: 1
       24 states, stored
        0 states, matched
       24 transitions (= stored+matched)
        0 atomic steps
hash conflicts:         0 (resolved)

Stats on memory usage (in Megabytes):
    0.006	equivalent memory usage for states (stored*(State-vector + overhead))
    0.289	actual memory usage for states
  128.000	memory used for hash table (-w24)
    0.534	memory used for DFS stack (-m10000)
  128.730	total actual memory usage



pan: elapsed time 0.021 seconds
To replay the error-trail, goto Simulate/Replay and select "Run"


===end VerOut===
srow0 	1
srow1 	5
srow2 	100
srow3 	10000
srow4 	4
srow5 	
srow6 	512M
srow7 	60m
srow8 	1.5
srow9 	512
srow10	250000
srow11	
srow12	-c1 -x -n
===start CCopts===
-DBITSTATE -DPUTPID             # basic dfs
-DBITSTATE -DPUTPID -DREVERSE   # reversed transition ordering
-DBITSTATE -DPUTPID -DT_REVERSE # reversed process ordering
-DBITSTATE -DPUTPID -DREVERSE -DT_REVERSE       # both
-DBITSTATE -DPUTPID -DP_RAND -DT_RAND   # same series with randomization
-DBITSTATE -DPUTPID -DP_RAND -DT_RAND -DT_REVERSE
-DBITSTATE -DPUTPID -DP_RAND -DT_RAND -DREVERSE
-DBITSTATE -DPUTPID -DP_RAND -DT_RAND -DREVERSE -DT_REVERSE


===end CCopts===
===start SwSetup===
swarm setup output


===end SwSetup===
===start SwRun===
swarm run output
no 'swarm' command is found
available from: http://spinroot.com/swarm/


===end SwRun===
